export { signRequest } from '@worldcoin/idkit-server';
import { keccak_256 } from '@noble/hashes/sha3';
import { hexToBytes, bytesToHex } from '@noble/hashes/utils';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/types/result.ts
var IDKitErrorCodes = /* @__PURE__ */ ((IDKitErrorCodes2) => {
  IDKitErrorCodes2["UserRejected"] = "user_rejected";
  IDKitErrorCodes2["VerificationRejected"] = "verification_rejected";
  IDKitErrorCodes2["CredentialUnavailable"] = "credential_unavailable";
  IDKitErrorCodes2["MalformedRequest"] = "malformed_request";
  IDKitErrorCodes2["InvalidNetwork"] = "invalid_network";
  IDKitErrorCodes2["InclusionProofPending"] = "inclusion_proof_pending";
  IDKitErrorCodes2["InclusionProofFailed"] = "inclusion_proof_failed";
  IDKitErrorCodes2["UnexpectedResponse"] = "unexpected_response";
  IDKitErrorCodes2["ConnectionFailed"] = "connection_failed";
  IDKitErrorCodes2["MaxVerificationsReached"] = "max_verifications_reached";
  IDKitErrorCodes2["FailedByHostApp"] = "failed_by_host_app";
  IDKitErrorCodes2["GenericError"] = "generic_error";
  IDKitErrorCodes2["Timeout"] = "timeout";
  IDKitErrorCodes2["Cancelled"] = "cancelled";
  return IDKitErrorCodes2;
})(IDKitErrorCodes || {});

// wasm/idkit_wasm.js
var idkit_wasm_exports = {};
__export(idkit_wasm_exports, {
  BridgeEncryption: () => BridgeEncryption,
  CredentialRequestWasm: () => CredentialRequestWasm,
  IDKitBuilder: () => IDKitBuilder,
  IDKitProof: () => IDKitProof,
  IDKitRequest: () => IDKitRequest,
  RpContextWasm: () => RpContextWasm,
  RpSignature: () => RpSignature,
  base64Decode: () => base64Decode,
  base64Encode: () => base64Encode,
  createSession: () => createSession,
  default: () => idkit_wasm_default,
  hashSignal: () => hashSignal,
  initSync: () => initSync,
  init_wasm: () => init_wasm,
  proveSession: () => proveSession,
  request: () => request,
  signRequest: () => signRequest
});
var wasm;
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var MAX_SAFARI_DECODE_BYTES = 2146435072;
var numBytesDecoded = 0;
function decodeText(ptr, len) {
  numBytesDecoded += len;
  if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
    cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    numBytesDecoded = len;
  }
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return decodeText(ptr, len);
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getObject(idx) {
  return heap[idx];
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder();
if (!("encodeInto" in cachedTextEncoder)) {
  cachedTextEncoder.encodeInto = function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = cachedTextEncoder.encodeInto(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_export3(addHeapObject(e));
  }
}
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((state) => state.dtor(state.a, state.b));
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      state.a = a;
      real._wbg_cb_unref();
    }
  };
  real._wbg_cb_unref = () => {
    if (--state.cnt === 0) {
      state.dtor(state.a, state.b);
      state.a = 0;
      CLOSURE_DTORS.unregister(state);
    }
  };
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
}
function createSession(app_id, rp_context, action_description, bridge_url, override_connect_base_url, environment) {
  const ptr0 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  const len0 = WASM_VECTOR_LEN;
  _assertClass(rp_context, RpContextWasm);
  var ptr1 = rp_context.__destroy_into_raw();
  var ptr2 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len2 = WASM_VECTOR_LEN;
  var ptr3 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len3 = WASM_VECTOR_LEN;
  var ptr4 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len4 = WASM_VECTOR_LEN;
  var ptr5 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len5 = WASM_VECTOR_LEN;
  const ret = wasm.createSession(ptr0, len0, ptr1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5);
  return IDKitBuilder.__wrap(ret);
}
function request(app_id, action, rp_context, action_description, bridge_url, allow_legacy_proofs, override_connect_base_url, environment) {
  const ptr0 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(action, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  const len1 = WASM_VECTOR_LEN;
  _assertClass(rp_context, RpContextWasm);
  var ptr2 = rp_context.__destroy_into_raw();
  var ptr3 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len3 = WASM_VECTOR_LEN;
  var ptr4 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len4 = WASM_VECTOR_LEN;
  var ptr5 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len5 = WASM_VECTOR_LEN;
  var ptr6 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len6 = WASM_VECTOR_LEN;
  const ret = wasm.idkitbuilder_new(ptr0, len0, ptr1, len1, ptr2, ptr3, len3, ptr4, len4, allow_legacy_proofs, ptr5, len5, ptr6, len6);
  return IDKitBuilder.__wrap(ret);
}
function base64Decode(data) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(data, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len0 = WASM_VECTOR_LEN;
    wasm.base64Decode(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    var v2 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_export4(r0, r1 * 1, 1);
    return v2;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function proveSession(session_id, app_id, rp_context, action_description, bridge_url, override_connect_base_url, environment) {
  const ptr0 = passStringToWasm0(session_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  const len1 = WASM_VECTOR_LEN;
  _assertClass(rp_context, RpContextWasm);
  var ptr2 = rp_context.__destroy_into_raw();
  var ptr3 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len3 = WASM_VECTOR_LEN;
  var ptr4 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len4 = WASM_VECTOR_LEN;
  var ptr5 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len5 = WASM_VECTOR_LEN;
  var ptr6 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
  var len6 = WASM_VECTOR_LEN;
  const ret = wasm.idkitbuilder_forProveSession(ptr0, len0, ptr1, len1, ptr2, ptr3, len3, ptr4, len4, ptr5, len5, ptr6, len6);
  return IDKitBuilder.__wrap(ret);
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function base64Encode(data) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export);
    const len0 = WASM_VECTOR_LEN;
    wasm.base64Encode(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    deferred2_0 = r0;
    deferred2_1 = r1;
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export4(deferred2_0, deferred2_1, 1);
  }
}
function init_wasm() {
  wasm.init_wasm();
}
function signRequest(action, signing_key_hex, ttl_seconds) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(action, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(signing_key_hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    wasm.signRequest(retptr, ptr0, len0, ptr1, len1, !isLikeNone(ttl_seconds), isLikeNone(ttl_seconds) ? BigInt(0) : ttl_seconds);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return RpSignature.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function hashSignal(signal) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.hashSignal(retptr, addHeapObject(signal));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export4(deferred2_0, deferred2_1, 1);
  }
}
function __wasm_bindgen_func_elem_605(arg0, arg1) {
  wasm.__wasm_bindgen_func_elem_605(arg0, arg1);
}
function __wasm_bindgen_func_elem_968(arg0, arg1, arg2) {
  wasm.__wasm_bindgen_func_elem_968(arg0, arg1, addHeapObject(arg2));
}
function __wasm_bindgen_func_elem_1353(arg0, arg1, arg2, arg3) {
  wasm.__wasm_bindgen_func_elem_1353(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
var __wbindgen_enum_RequestCache = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"];
var __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];
var __wbindgen_enum_RequestMode = ["same-origin", "no-cors", "cors", "navigate"];
var BridgeEncryptionFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_bridgeencryption_free(ptr >>> 0, 1));
var BridgeEncryption = class {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BridgeEncryptionFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_bridgeencryption_free(ptr, 0);
  }
  /**
   * Returns the key as a base64-encoded string
   * @returns {string}
   */
  keyBase64() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.bridgeencryption_keyBase64(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Returns the nonce as a base64-encoded string
   * @returns {string}
   */
  nonceBase64() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.bridgeencryption_nonceBase64(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Creates a new `BridgeEncryption` instance with randomly generated key and nonce
   *
   * # Errors
   *
   * Returns an error if key generation fails
   */
  constructor() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.bridgeencryption_new(retptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      BridgeEncryptionFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Decrypts a base64-encoded ciphertext using AES-256-GCM
   *
   * # Errors
   *
   * Returns an error if decryption fails or the output is not valid UTF-8
   * @param {string} ciphertext_base64
   * @returns {string}
   */
  decrypt(ciphertext_base64) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(ciphertext_base64, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len0 = WASM_VECTOR_LEN;
      wasm.bridgeencryption_decrypt(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0;
        len2 = 0;
        throw takeObject(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0(ptr2, len2);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * Encrypts a plaintext string using AES-256-GCM and returns base64
   *
   * # Errors
   *
   * Returns an error if encryption fails
   * @param {string} plaintext
   * @returns {string}
   */
  encrypt(plaintext) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len0 = WASM_VECTOR_LEN;
      wasm.bridgeencryption_encrypt(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0;
        len2 = 0;
        throw takeObject(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0(ptr2, len2);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred3_0, deferred3_1, 1);
    }
  }
};
if (Symbol.dispose) BridgeEncryption.prototype[Symbol.dispose] = BridgeEncryption.prototype.free;
var CredentialRequestWasmFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_credentialrequestwasm_free(ptr >>> 0, 1));
var CredentialRequestWasm = class _CredentialRequestWasm {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_CredentialRequestWasm.prototype);
    obj.__wbg_ptr = ptr;
    CredentialRequestWasmFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CredentialRequestWasmFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_credentialrequestwasm_free(ptr, 0);
  }
  /**
   * Creates a new request item with raw bytes for the signal
   *
   * # Errors
   *
   * Returns an error if the credential type is invalid
   * @param {any} credential_type
   * @param {Uint8Array} signal_bytes
   * @returns {CredentialRequestWasm}
   */
  static withBytes(credential_type, signal_bytes) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(signal_bytes, wasm.__wbindgen_export);
      const len0 = WASM_VECTOR_LEN;
      wasm.credentialrequestwasm_withBytes(retptr, addHeapObject(credential_type), ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _CredentialRequestWasm.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Gets the credential type
   * @returns {any}
   */
  credentialType() {
    const ret = wasm.credentialrequestwasm_credentialType(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Gets the signal as raw bytes
   * @returns {Uint8Array | undefined}
   */
  getSignalBytes() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.credentialrequestwasm_getSignalBytes(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export4(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new request item with genesis minimum timestamp
   *
   * # Errors
   *
   * Returns an error if the credential type is invalid
   * @param {any} credential_type
   * @param {string | null | undefined} signal
   * @param {bigint} genesis_min
   * @returns {CredentialRequestWasm}
   */
  static withGenesisMin(credential_type, signal, genesis_min) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(signal) ? 0 : passStringToWasm0(signal, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      var len0 = WASM_VECTOR_LEN;
      wasm.credentialrequestwasm_withGenesisMin(retptr, addHeapObject(credential_type), ptr0, len0, genesis_min);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _CredentialRequestWasm.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new request item with expiration minimum timestamp
   *
   * # Errors
   *
   * Returns an error if the credential type is invalid
   * @param {any} credential_type
   * @param {string | null | undefined} signal
   * @param {bigint} expires_at_min
   * @returns {CredentialRequestWasm}
   */
  static withExpiresAtMin(credential_type, signal, expires_at_min) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(signal) ? 0 : passStringToWasm0(signal, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      var len0 = WASM_VECTOR_LEN;
      wasm.credentialrequestwasm_withExpiresAtMin(retptr, addHeapObject(credential_type), ptr0, len0, expires_at_min);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _CredentialRequestWasm.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new request item
   *
   * # Arguments
   * * `credential_type` - The type of credential to request (e.g., "orb", "face")
   * * `signal` - Optional signal string
   *
   * # Errors
   *
   * Returns an error if the credential type is invalid
   * @param {any} credential_type
   * @param {string | null} [signal]
   */
  constructor(credential_type, signal) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(signal) ? 0 : passStringToWasm0(signal, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      var len0 = WASM_VECTOR_LEN;
      wasm.credentialrequestwasm_new(retptr, addHeapObject(credential_type), ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      CredentialRequestWasmFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Converts the request item to JSON
   *
   * # Errors
   *
   * Returns an error if serialization fails
   * @returns {any}
   */
  toJSON() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.credentialrequestwasm_toJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
if (Symbol.dispose) CredentialRequestWasm.prototype[Symbol.dispose] = CredentialRequestWasm.prototype.free;
var IDKitBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_idkitbuilder_free(ptr >>> 0, 1));
var IDKitBuilder = class _IDKitBuilder {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_IDKitBuilder.prototype);
    obj.__wbg_ptr = ptr;
    IDKitBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IDKitBuilderFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_idkitbuilder_free(ptr, 0);
  }
  /**
   * Creates a `BridgeConnection` with the given constraints
   * @param {any} constraints_json
   * @returns {Promise<any>}
   */
  constraints(constraints_json) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.idkitbuilder_constraints(ptr, addHeapObject(constraints_json));
    return takeObject(ret);
  }
  /**
   * Builds the native payload for constraints (synchronous, no bridge connection).
   *
   * Used by the native transport to get the same payload format as the bridge
   * without creating a network connection.
   *
   * # Errors
   *
   * Returns an error if constraints are invalid or payload construction fails.
   * @param {any} constraints_json
   * @returns {any}
   */
  nativePayload(constraints_json) {
    try {
      const ptr = this.__destroy_into_raw();
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.idkitbuilder_nativePayload(retptr, ptr, addHeapObject(constraints_json));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new builder for proving an existing session
   * @param {string} session_id
   * @param {string} app_id
   * @param {RpContextWasm} rp_context
   * @param {string | null} [action_description]
   * @param {string | null} [bridge_url]
   * @param {string | null} [override_connect_base_url]
   * @param {string | null} [environment]
   * @returns {IDKitBuilder}
   */
  static forProveSession(session_id, app_id, rp_context, action_description, bridge_url, override_connect_base_url, environment) {
    const ptr0 = passStringToWasm0(session_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    _assertClass(rp_context, RpContextWasm);
    var ptr2 = rp_context.__destroy_into_raw();
    var ptr3 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len3 = WASM_VECTOR_LEN;
    var ptr4 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len4 = WASM_VECTOR_LEN;
    var ptr5 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len5 = WASM_VECTOR_LEN;
    var ptr6 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len6 = WASM_VECTOR_LEN;
    const ret = wasm.idkitbuilder_forProveSession(ptr0, len0, ptr1, len1, ptr2, ptr3, len3, ptr4, len4, ptr5, len5, ptr6, len6);
    return _IDKitBuilder.__wrap(ret);
  }
  /**
   * Creates a new builder for creating a new session
   * @param {string} app_id
   * @param {RpContextWasm} rp_context
   * @param {string | null} [action_description]
   * @param {string | null} [bridge_url]
   * @param {string | null} [override_connect_base_url]
   * @param {string | null} [environment]
   * @returns {IDKitBuilder}
   */
  static forCreateSession(app_id, rp_context, action_description, bridge_url, override_connect_base_url, environment) {
    const ptr0 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(rp_context, RpContextWasm);
    var ptr1 = rp_context.__destroy_into_raw();
    var ptr2 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len3 = WASM_VECTOR_LEN;
    var ptr4 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len4 = WASM_VECTOR_LEN;
    var ptr5 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len5 = WASM_VECTOR_LEN;
    const ret = wasm.createSession(ptr0, len0, ptr1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5);
    return _IDKitBuilder.__wrap(ret);
  }
  /**
   * Builds the native payload from a preset (synchronous, no bridge connection).
   *
   * Used by the native transport to get the same payload format as the bridge
   * without creating a network connection.
   *
   * # Errors
   *
   * Returns an error if the preset is invalid or payload construction fails.
   * @param {any} preset_json
   * @returns {any}
   */
  nativePayloadFromPreset(preset_json) {
    try {
      const ptr = this.__destroy_into_raw();
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.idkitbuilder_nativePayloadFromPreset(retptr, ptr, addHeapObject(preset_json));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new builder for uniqueness requests
   * @param {string} app_id
   * @param {string} action
   * @param {RpContextWasm} rp_context
   * @param {string | null | undefined} action_description
   * @param {string | null | undefined} bridge_url
   * @param {boolean} allow_legacy_proofs
   * @param {string | null} [override_connect_base_url]
   * @param {string | null} [environment]
   */
  constructor(app_id, action, rp_context, action_description, bridge_url, allow_legacy_proofs, override_connect_base_url, environment) {
    const ptr0 = passStringToWasm0(app_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(action, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    _assertClass(rp_context, RpContextWasm);
    var ptr2 = rp_context.__destroy_into_raw();
    var ptr3 = isLikeNone(action_description) ? 0 : passStringToWasm0(action_description, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len3 = WASM_VECTOR_LEN;
    var ptr4 = isLikeNone(bridge_url) ? 0 : passStringToWasm0(bridge_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len4 = WASM_VECTOR_LEN;
    var ptr5 = isLikeNone(override_connect_base_url) ? 0 : passStringToWasm0(override_connect_base_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len5 = WASM_VECTOR_LEN;
    var ptr6 = isLikeNone(environment) ? 0 : passStringToWasm0(environment, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len6 = WASM_VECTOR_LEN;
    const ret = wasm.idkitbuilder_new(ptr0, len0, ptr1, len1, ptr2, ptr3, len3, ptr4, len4, allow_legacy_proofs, ptr5, len5, ptr6, len6);
    this.__wbg_ptr = ret >>> 0;
    IDKitBuilderFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * Creates a `BridgeConnection` from a preset (works for all request types)
   * @param {any} preset_json
   * @returns {Promise<any>}
   */
  preset(preset_json) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.idkitbuilder_preset(ptr, addHeapObject(preset_json));
    return takeObject(ret);
  }
};
if (Symbol.dispose) IDKitBuilder.prototype[Symbol.dispose] = IDKitBuilder.prototype.free;
var IDKitProofFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_idkitproof_free(ptr >>> 0, 1));
var IDKitProof = class {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IDKitProofFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_idkitproof_free(ptr, 0);
  }
  /**
   * Creates a new legacy proof (protocol v1 / World ID v3)
   *
   * # Errors
   *
   * Returns an error if the verification level cannot be deserialized
   * @param {string} proof
   * @param {string} merkle_root
   * @param {string} nullifier_hash
   * @param {any} verification_level
   */
  constructor(proof, merkle_root, nullifier_hash, verification_level) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(proof, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(merkle_root, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len1 = WASM_VECTOR_LEN;
      const ptr2 = passStringToWasm0(nullifier_hash, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len2 = WASM_VECTOR_LEN;
      wasm.idkitproof_new(retptr, ptr0, len0, ptr1, len1, ptr2, len2, addHeapObject(verification_level));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      IDKitProofFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Converts the proof to JSON
   *
   * # Errors
   *
   * Returns an error if serialization fails
   * @returns {any}
   */
  toJSON() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.idkitproof_toJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
if (Symbol.dispose) IDKitProof.prototype[Symbol.dispose] = IDKitProof.prototype.free;
var IDKitRequestFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_idkitrequest_free(ptr >>> 0, 1));
var IDKitRequest = class _IDKitRequest {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_IDKitRequest.prototype);
    obj.__wbg_ptr = ptr;
    IDKitRequestFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IDKitRequestFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_idkitrequest_free(ptr, 0);
  }
  /**
   * Returns the request ID for this request
   *
   * # Errors
   *
   * Returns an error if the request has been closed
   * @returns {string}
   */
  requestId() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.idkitrequest_requestId(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * Returns the connect URL for World App
   *
   * This URL should be displayed as a QR code for users to scan with World App.
   *
   * # Errors
   *
   * Returns an error if the request has been closed
   * @returns {string}
   */
  connectUrl() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.idkitrequest_connectUrl(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * Polls the bridge for the current status (non-blocking)
   *
   * Returns a status object with type:
   * - `"waiting_for_connection"` - Waiting for World App to retrieve the request
   * - `"awaiting_confirmation"` - World App has retrieved the request, waiting for user
   * - `"confirmed"` - User confirmed and provided a proof
   * - `"failed"` - Request has failed
   *
   * # Errors
   *
   * Returns an error if the request fails or the response is invalid
   * @returns {Promise<any>}
   */
  pollForStatus() {
    const ret = wasm.idkitrequest_pollForStatus(this.__wbg_ptr);
    return takeObject(ret);
  }
};
if (Symbol.dispose) IDKitRequest.prototype[Symbol.dispose] = IDKitRequest.prototype.free;
var RpContextWasmFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_rpcontextwasm_free(ptr >>> 0, 1));
var RpContextWasm = class {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RpContextWasmFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rpcontextwasm_free(ptr, 0);
  }
  /**
   * Creates a new RP context
   *
   * # Arguments
   * * `rp_id` - The registered RP ID (e.g., `"rp_123456789abcdef0"`)
   * * `nonce` - Unique nonce for this proof request
   * * `created_at` - Unix timestamp (seconds since epoch) when created
   * * `expires_at` - Unix timestamp (seconds since epoch) when expires
   * * `signature` - The RP's ECDSA signature of the `nonce` and `created_at` timestamp
   *
   * # Errors
   *
   * Returns an error if `rp_id` is not a valid RP ID (must start with `rp_`)
   * @param {string} rp_id
   * @param {string} nonce
   * @param {bigint} created_at
   * @param {bigint} expires_at
   * @param {string} signature
   */
  constructor(rp_id, nonce, created_at, expires_at, signature) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(rp_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(nonce, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len1 = WASM_VECTOR_LEN;
      const ptr2 = passStringToWasm0(signature, wasm.__wbindgen_export, wasm.__wbindgen_export2);
      const len2 = WASM_VECTOR_LEN;
      wasm.rpcontextwasm_new(retptr, ptr0, len0, ptr1, len1, created_at, expires_at, ptr2, len2);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      RpContextWasmFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
if (Symbol.dispose) RpContextWasm.prototype[Symbol.dispose] = RpContextWasm.prototype.free;
var RpSignatureFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_rpsignature_free(ptr >>> 0, 1));
var RpSignature = class _RpSignature {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_RpSignature.prototype);
    obj.__wbg_ptr = ptr;
    RpSignatureFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RpSignatureFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rpsignature_free(ptr, 0);
  }
  /**
   * Gets the creation timestamp
   * @returns {bigint}
   */
  get createdAt() {
    const ret = wasm.rpsignature_createdAt(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * Gets the expiration timestamp
   * @returns {bigint}
   */
  get expiresAt() {
    const ret = wasm.rpsignature_expiresAt(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * Gets the signature as hex string (0x-prefixed, 65 bytes)
   * @returns {string}
   */
  get sig() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpsignature_sig(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Gets the nonce as hex string (0x-prefixed field element)
   * @returns {string}
   */
  get nonce() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpsignature_nonce(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export4(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Converts to JSON
   *
   * # Errors
   *
   * Returns an error if setting object properties fails
   * @returns {any}
   */
  toJSON() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpsignature_toJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
if (Symbol.dispose) RpSignature.prototype[Symbol.dispose] = RpSignature.prototype.free;
var EXPECTED_RESPONSE_TYPES = /* @__PURE__ */ new Set(["basic", "cors", "default"]);
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        const validResponse = module2.ok && EXPECTED_RESPONSE_TYPES.has(module2.type);
        if (validResponse && module2.headers.get("Content-Type") !== "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_Error_e83987f665cf5504 = function(arg0, arg1) {
    const ret = Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg___wbindgen_bigint_get_as_i64_f3ebc5a755000afd = function(arg0, arg1) {
    const v = getObject(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbg___wbindgen_boolean_get_6d5a1ee65bab5f68 = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v : void 0;
    return isLikeNone(ret) ? 16777215 : ret ? 1 : 0;
  };
  imports.wbg.__wbg___wbindgen_debug_string_df47ffb5e35e6763 = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg___wbindgen_in_bb933bd9e1b3bc0f = function(arg0, arg1) {
    const ret = getObject(arg0) in getObject(arg1);
    return ret;
  };
  imports.wbg.__wbg___wbindgen_is_bigint_cb320707dcd35f0b = function(arg0) {
    const ret = typeof getObject(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbg___wbindgen_is_function_ee8a6c5833c90377 = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg___wbindgen_is_object_c818261d21f283a4 = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg___wbindgen_is_string_fbb76cb2940daafd = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg___wbindgen_is_undefined_2d472862bd29a478 = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg___wbindgen_jsval_eq_6b13ab83478b1c50 = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
  };
  imports.wbg.__wbg___wbindgen_jsval_loose_eq_b664b38a2f582147 = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbg___wbindgen_number_get_a20bf9b85341449d = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbg___wbindgen_string_get_e4f06c90489ad01b = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg___wbindgen_throw_b855445ff6a94295 = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg__wbg_cb_unref_2454a539ea5790d9 = function(arg0) {
    getObject(arg0)._wbg_cb_unref();
  };
  imports.wbg.__wbg_abort_28ad55c5825b004d = function(arg0, arg1) {
    getObject(arg0).abort(getObject(arg1));
  };
  imports.wbg.__wbg_abort_e7eb059f72f9ed0c = function(arg0) {
    getObject(arg0).abort();
  };
  imports.wbg.__wbg_append_b577eb3a177bc0fa = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_arrayBuffer_b375eccb84b4ddf3 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).arrayBuffer();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_525440f72fbfc0ea = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_e762c39fa8ea36bf = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_clearTimeout_7a42b49784aea641 = function(arg0) {
    const ret = clearTimeout(takeObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_done_2042aa2670fb1db1 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_entries_e171b586f8f6bdbf = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_export4(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_fetch_74a3e84ebd2c9a0e = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_f8ba0e29a9d6de0d = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getRandomValues_38a1ff1ea09f6cc7 = function() {
    return handleError(function(arg0, arg1) {
      globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));
    }, arguments);
  };
  imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_get_7bed016f185add81 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_efcb449f58ec27c2 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_has_787fafc980c3ccdb = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.has(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_headers_b87d7eaba61c3278 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_idkitrequest_new = function(arg0) {
    const ret = IDKitRequest.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_70beb1189ca63b38 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Map_8579b5e2ab5437c7 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Response_f4f3e87e07f3135c = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Response;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_20c8e73002f7af98 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_isArray_96e0af9891d0945d = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_isSafeInteger_d216eda7911dde36 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_iterator_e5822695327a3c39 = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_69bca3cb64fc8748 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_cdd215e10d9dd507 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_1acc0b6eea89d040 = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_2531773dac38ebb3 = function() {
    return handleError(function() {
      const ret = new AbortController();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_3c3d849046688a66 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wasm_bindgen_func_elem_1353(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_new_5a79be3ab53b8aa5 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_68651c719dcda04e = function() {
    const ret = /* @__PURE__ */ new Map();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_9edf9838a2def39c = function() {
    return handleError(function() {
      const ret = new Headers();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_e17d9f43105b08be = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_from_slice_92f4d78ca282a2d2 = function(arg0, arg1) {
    const ret = new Uint8Array(getArrayU8FromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_no_args_ee98eee5275000a4 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_with_length_01aa0dc35aa13543 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_with_str_and_init_0ae7728b6ec367b1 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_020810e0ae8ebcb0 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_2c826fe5dfec6b6a = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_now_793306c526e2e3b6 = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_prototypesetcall_2a6620b6922694b2 = function(arg0, arg1, arg2) {
    Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));
  };
  imports.wbg.__wbg_queueMicrotask_34d692c25c47d05b = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_queueMicrotask_9d76cacb20c84d58 = function(arg0) {
    queueMicrotask(getObject(arg0));
  };
  imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_require_60cc747a6bc5215a = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_resolve_caf97c30b83f7053 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_setTimeout_7bb3429662ab1e70 = function(arg0, arg1) {
    const ret = setTimeout(getObject(arg0), arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_907fb406c34a251d = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_body_3c365989753d61f4 = function(arg0, arg1) {
    getObject(arg0).body = getObject(arg1);
  };
  imports.wbg.__wbg_set_c213c871859d6500 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_c2abbebe8b9ebee1 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_cache_2f9deb19b92b81e3 = function(arg0, arg1) {
    getObject(arg0).cache = __wbindgen_enum_RequestCache[arg1];
  };
  imports.wbg.__wbg_set_credentials_f621cd2d85c0c228 = function(arg0, arg1) {
    getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];
  };
  imports.wbg.__wbg_set_headers_6926da238cd32ee4 = function(arg0, arg1) {
    getObject(arg0).headers = getObject(arg1);
  };
  imports.wbg.__wbg_set_method_c02d8cbbe204ac2d = function(arg0, arg1, arg2) {
    getObject(arg0).method = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_set_mode_52ef73cfa79639cb = function(arg0, arg1) {
    getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];
  };
  imports.wbg.__wbg_set_signal_dda2cf7ccb6bee0f = function(arg0, arg1) {
    getObject(arg0).signal = getObject(arg1);
  };
  imports.wbg.__wbg_signal_4db5aa055bf9eb9a = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_89e1d9ac6a1b250e = function() {
    const ret = typeof global === "undefined" ? null : global;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_8b530f326a9e48ac = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_6fdf4b64710cc91b = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_b45bfc5a37f6cfa2 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_status_de7eed5a7a5bfd5d = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_stringify_b5fb28f6465d9c3e = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_subarray_480600f3d6a9f26c = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_text_dc33c15c17bdfb52 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).text();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_then_4f46f6544e6b4a28 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_70d05cf780a18d77 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_url_b36d2a5008eb056f = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_value_692627309814bb8c = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_02740531cfdb05fe = function(arg0, arg1) {
    const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_604, __wasm_bindgen_func_elem_605);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_9ae0607507abb057 = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_cb9088102bce6b30 = function(arg0, arg1) {
    const ret = getArrayU8FromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cast_f23235b6472d5cf3 = function(arg0, arg1) {
    const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_967, __wasm_bindgen_func_elem_968);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  return imports;
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
function initSync(module2) {
  if (wasm !== void 0) return wasm;
  if (typeof module2 !== "undefined") {
    if (Object.getPrototypeOf(module2) === Object.prototype) {
      ({ module: module2 } = module2);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports = __wbg_get_imports();
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init(instance, module2);
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("idkit_wasm_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module2);
}
var idkit_wasm_default = __wbg_init;

// src/lib/wasm.ts
var wasmInitialized = false;
var wasmInitPromise = null;
async function initIDKit() {
  if (wasmInitialized) {
    return;
  }
  if (wasmInitPromise) {
    return wasmInitPromise;
  }
  wasmInitPromise = (async () => {
    try {
      await idkit_wasm_default();
      wasmInitialized = true;
    } catch (error) {
      wasmInitPromise = null;
      throw new Error(`Failed to initialize IDKit WASM: ${error}`);
    }
  })();
  return wasmInitPromise;
}

// src/transports/native.ts
var MINIAPP_VERIFY_ACTION = "miniapp-verify-action";
function isInWorldApp() {
  return typeof window !== "undefined" && Boolean(window.WorldApp);
}
var _requestCounter = 0;
var _activeNativeRequest = null;
function createNativeRequest(wasmPayload, config, signalHashes = {}) {
  if (_activeNativeRequest?.isPending()) {
    console.warn(
      "IDKit native request already in flight. Reusing active request."
    );
    return _activeNativeRequest;
  }
  const request2 = new NativeIDKitRequest(wasmPayload, config, signalHashes);
  _activeNativeRequest = request2;
  return request2;
}
var NativeIDKitRequest = class {
  constructor(wasmPayload, config, signalHashes = {}) {
    this.connectorURI = "";
    this.resolved = false;
    this.cancelled = false;
    this.settled = false;
    this.resolvedResult = null;
    this.messageHandler = null;
    this.miniKitHandler = null;
    this.rejectFn = null;
    this.requestId = crypto.randomUUID?.() ?? `native-${Date.now()}-${++_requestCounter}`;
    this.resultPromise = new Promise((resolve, reject) => {
      this.rejectFn = reject;
      const handleIncomingPayload = (responsePayload) => {
        if (this.cancelled || this.resolved || this.settled) return;
        if (responsePayload?.status === "error") {
          this.cleanup();
          reject(
            new NativeVerifyError(
              responsePayload.error_code ?? "generic_error" /* GenericError */
            )
          );
          return;
        }
        this.resolved = true;
        const result = nativeResultToIDKitResult(
          responsePayload,
          config,
          signalHashes
        );
        this.resolvedResult = result;
        this.cleanup();
        resolve(result);
      };
      const handler = (event) => {
        const data = event.data;
        if (data?.type === MINIAPP_VERIFY_ACTION || data?.command === MINIAPP_VERIFY_ACTION) {
          handleIncomingPayload(data.payload ?? data);
        }
      };
      this.messageHandler = handler;
      window.addEventListener("message", handler);
      try {
        const miniKit = window.MiniKit;
        if (typeof miniKit?.subscribe === "function") {
          const miniKitHandler = (payload) => {
            handleIncomingPayload(payload?.payload ?? payload);
          };
          this.miniKitHandler = miniKitHandler;
          miniKit.subscribe(MINIAPP_VERIFY_ACTION, miniKitHandler);
        }
      } catch {
      }
      const sendPayload = {
        command: "verify",
        version: 2,
        payload: wasmPayload
      };
      const w = window;
      if (w.webkit?.messageHandlers?.minikit) {
        w.webkit.messageHandlers.minikit.postMessage(sendPayload);
      } else if (w.Android) {
        w.Android.postMessage(JSON.stringify(sendPayload));
      } else {
        this.cleanup();
        reject(new Error("No WebView bridge available"));
      }
    });
    this.resultPromise.catch(() => {
    }).finally(() => {
      this.settled = true;
      this.cleanup();
      if (_activeNativeRequest === this) {
        _activeNativeRequest = null;
      }
    });
  }
  /**
   * Cancel this request. Removes the message listener so it cannot consume
   * a response meant for a later request, and rejects the pending promise.
   */
  cancel() {
    if (this.resolved || this.cancelled) return;
    this.cancelled = true;
    this.cleanup();
    this.rejectFn?.(new NativeVerifyError("cancelled" /* Cancelled */));
    if (_activeNativeRequest === this) {
      _activeNativeRequest = null;
    }
  }
  cleanup() {
    if (this.messageHandler) {
      window.removeEventListener("message", this.messageHandler);
      this.messageHandler = null;
    }
    if (this.miniKitHandler) {
      try {
        const miniKit = window.MiniKit;
        miniKit?.unsubscribe?.(MINIAPP_VERIFY_ACTION);
      } catch {
      }
      this.miniKitHandler = null;
    }
  }
  isPending() {
    return !this.settled && !this.cancelled;
  }
  async pollOnce() {
    if (this.resolved && this.resolvedResult) {
      return { type: "confirmed", result: this.resolvedResult };
    }
    return { type: "awaiting_confirmation" };
  }
  async pollUntilCompletion(options) {
    const timeout = options?.timeout ?? 3e5;
    let timeoutId;
    let abortHandler = null;
    let waiterTerminationCode = null;
    try {
      const result = await Promise.race([
        this.resultPromise,
        new Promise((_, reject) => {
          if (options?.signal) {
            abortHandler = () => {
              waiterTerminationCode = "cancelled" /* Cancelled */;
              reject(new NativeVerifyError("cancelled" /* Cancelled */));
            };
            if (options.signal.aborted) {
              abortHandler();
              return;
            }
            options.signal.addEventListener("abort", abortHandler, {
              once: true
            });
          }
          timeoutId = setTimeout(() => {
            waiterTerminationCode = "timeout" /* Timeout */;
            reject(new NativeVerifyError("timeout" /* Timeout */));
          }, timeout);
        })
      ]);
      return { success: true, result };
    } catch (error) {
      if (error instanceof NativeVerifyError) {
        if (waiterTerminationCode === error.code && this.isPending()) {
          this.cancel();
        }
        return { success: false, error: error.code };
      }
      return { success: false, error: "generic_error" /* GenericError */ };
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      if (options?.signal && abortHandler) {
        options.signal.removeEventListener("abort", abortHandler);
      }
    }
  }
};
var NativeVerifyError = class extends Error {
  constructor(code) {
    super(code);
    this.code = code;
  }
};
function nativeResultToIDKitResult(payload, config, signalHashes) {
  const p = payload;
  const rpNonce = config.rp_context?.nonce ?? "";
  if ("responses" in p && Array.isArray(p.responses)) {
    const items = p.responses;
    if (p.session_id) {
      return {
        protocol_version: "4.0",
        nonce: p.nonce ?? rpNonce,
        action_description: p.action_description,
        session_id: p.session_id,
        responses: items.map((item) => ({
          identifier: item.identifier,
          signal_hash: signalHashes[item.identifier],
          proof: item.proof,
          session_nullifier: item.session_nullifier,
          issuer_schema_id: item.issuer_schema_id,
          expires_at_min: item.expires_at_min
        })),
        environment: config.environment ?? "production"
      };
    }
    return {
      protocol_version: "4.0",
      nonce: p.nonce ?? rpNonce,
      action: p.action ?? config.action ?? "",
      action_description: p.action_description,
      responses: items.map((item) => ({
        identifier: item.identifier,
        signal_hash: signalHashes[item.identifier],
        proof: item.proof,
        nullifier: item.nullifier,
        issuer_schema_id: item.issuer_schema_id,
        expires_at_min: item.expires_at_min
      })),
      environment: config.environment ?? "production"
    };
  }
  if ("verifications" in p && Array.isArray(p.verifications)) {
    const verifications = p.verifications;
    return {
      protocol_version: "3.0",
      nonce: rpNonce,
      action: config.action ?? "",
      responses: verifications.map((v) => ({
        identifier: v.verification_level,
        signal_hash: v.signal_hash ?? signalHashes[v.verification_level],
        proof: v.proof,
        merkle_root: v.merkle_root,
        nullifier: v.nullifier_hash
      })),
      environment: config.environment ?? "production"
    };
  }
  return {
    protocol_version: "3.0",
    nonce: rpNonce,
    action: config.action ?? "",
    responses: [
      {
        identifier: p.verification_level,
        signal_hash: p.signal_hash ?? signalHashes[p.verification_level],
        proof: p.proof,
        merkle_root: p.merkle_root,
        nullifier: p.nullifier_hash
      }
    ],
    environment: config.environment ?? "production"
  };
}

// src/request.ts
var IDKitRequestImpl = class {
  constructor(wasmRequest) {
    this.wasmRequest = wasmRequest;
    this._connectorURI = wasmRequest.connectUrl();
    this._requestId = wasmRequest.requestId();
  }
  get connectorURI() {
    return this._connectorURI;
  }
  get requestId() {
    return this._requestId;
  }
  async pollOnce() {
    return await this.wasmRequest.pollForStatus();
  }
  async pollUntilCompletion(options) {
    const pollInterval = options?.pollInterval ?? 1e3;
    const timeout = options?.timeout ?? 3e5;
    const startTime = Date.now();
    while (true) {
      if (options?.signal?.aborted) {
        return { success: false, error: "cancelled" /* Cancelled */ };
      }
      if (Date.now() - startTime > timeout) {
        return { success: false, error: "timeout" /* Timeout */ };
      }
      const status = await this.pollOnce();
      if (status.type === "confirmed" && status.result) {
        return { success: true, result: status.result };
      }
      if (status.type === "failed") {
        return {
          success: false,
          error: status.error ?? "generic_error" /* GenericError */
        };
      }
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
  }
};
function orbLegacy(opts = {}) {
  return { type: "OrbLegacy", signal: opts.signal };
}
function secureDocumentLegacy(opts = {}) {
  return { type: "SecureDocumentLegacy", signal: opts.signal };
}
function documentLegacy(opts = {}) {
  return { type: "DocumentLegacy", signal: opts.signal };
}
function selfieCheck(opts = {}) {
  return { type: "SelfieCheck", signal: opts.signal };
}
function createWasmBuilderFromConfig(config) {
  if (!config.rp_context) {
    throw new Error("rp_context is required for WASM bridge transport");
  }
  const rpContext = new idkit_wasm_exports.RpContextWasm(
    config.rp_context.rp_id,
    config.rp_context.nonce,
    BigInt(config.rp_context.created_at),
    BigInt(config.rp_context.expires_at),
    config.rp_context.signature
  );
  if (config.type === "request") {
    return idkit_wasm_exports.request(
      config.app_id,
      String(config.action ?? ""),
      rpContext,
      config.action_description ?? null,
      config.bridge_url ?? null,
      config.allow_legacy_proofs ?? false,
      config.override_connect_base_url ?? null,
      config.environment ?? null
    );
  }
  if (config.type === "proveSession") {
    return idkit_wasm_exports.proveSession(
      config.session_id,
      config.app_id,
      rpContext,
      config.action_description ?? null,
      config.bridge_url ?? null,
      config.override_connect_base_url ?? null,
      config.environment ?? null
    );
  }
  return idkit_wasm_exports.createSession(
    config.app_id,
    rpContext,
    config.action_description ?? null,
    config.bridge_url ?? null,
    config.override_connect_base_url ?? null,
    config.environment ?? null
  );
}
var IDKitBuilder2 = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Creates an IDKit request with the given constraints
   *
   * @param constraints - Constraint tree (CredentialRequest or any/all/enumerate combinators)
   * @returns A new IDKitRequest instance
   *
   * @example
   * ```typescript
   * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: false })
   *   .constraints(any(CredentialRequest('orb'), CredentialRequest('face')));
   * ```
   */
  async constraints(constraints) {
    await initIDKit();
    const wasmBuilder = createWasmBuilderFromConfig(this.config);
    if (isInWorldApp()) {
      const wasmResult = wasmBuilder.nativePayload(constraints);
      return createNativeRequest(
        wasmResult.payload,
        this.config,
        wasmResult.signal_hashes ?? {}
      );
    }
    const wasmRequest = await wasmBuilder.constraints(
      constraints
    );
    return new IDKitRequestImpl(wasmRequest);
  }
  /**
   * Creates an IDKit request from a preset (works for all request types)
   *
   * Presets provide a simplified way to create requests with predefined
   * credential configurations.
   *
   * @param preset - A preset object from orbLegacy(), secureDocumentLegacy(), documentLegacy(), or selfieCheck()
   * @returns A new IDKitRequest instance
   *
   * @example
   * ```typescript
   * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: true })
   *   .preset(orbLegacy({ signal: 'user-123' }));
   * ```
   */
  async preset(preset) {
    await initIDKit();
    const wasmBuilder = createWasmBuilderFromConfig(this.config);
    if (isInWorldApp()) {
      const wasmResult = wasmBuilder.nativePayloadFromPreset(preset);
      return createNativeRequest(
        wasmResult.payload,
        this.config,
        wasmResult.signal_hashes ?? {}
      );
    }
    const wasmRequest = await wasmBuilder.preset(
      preset
    );
    return new IDKitRequestImpl(wasmRequest);
  }
};
function createRequest(config) {
  if (!config.app_id) {
    throw new Error("app_id is required");
  }
  if (!config.action) {
    throw new Error("action is required");
  }
  if (!config.rp_context) {
    throw new Error(
      "rp_context is required. Generate it on your backend using signRequest()."
    );
  }
  if (typeof config.allow_legacy_proofs !== "boolean") {
    throw new Error(
      "allow_legacy_proofs is required. Set to true to accept v3 proofs during migration, or false to only accept v4 proofs."
    );
  }
  return new IDKitBuilder2({
    type: "request",
    app_id: config.app_id,
    action: String(config.action),
    rp_context: config.rp_context,
    action_description: config.action_description,
    bridge_url: config.bridge_url,
    allow_legacy_proofs: config.allow_legacy_proofs,
    override_connect_base_url: config.override_connect_base_url,
    environment: config.environment
  });
}
var IDKit = {
  /** Create a new verification request */
  request: createRequest,
  // TODO: Re-enable when World ID 4.0 is live
  // /** Create a new session (no action, no existing session_id) */
  // createSession,
  // /** Prove an existing session (no action, has session_id) */
  // proveSession,
  // /** Create a CredentialRequest for a credential type */
  // CredentialRequest,
  // /** Create an OR constraint - at least one child must be satisfied */
  // any,
  // /** Create an AND constraint - all children must be satisfied */
  // all,
  // /** Create an enumerate constraint - all satisfiable children should be selected */
  // enumerate,
  /** Create an OrbLegacy preset for World ID 3.0 legacy support */
  orbLegacy,
  /** Create a SecureDocumentLegacy preset for World ID 3.0 legacy support */
  secureDocumentLegacy,
  /** Create a DocumentLegacy preset for World ID 3.0 legacy support */
  documentLegacy,
  /** Create a SelfieCheck preset for face verification */
  selfieCheck
};

// src/lib/platform.ts
var isReactNative = () => {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product === "ReactNative";
};
var isWeb = () => {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
};
var isNode = () => {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
};
function hashToField(input) {
  const hash = BigInt("0x" + bytesToHex(keccak_256(input))) >> 8n;
  return hexToBytes(hash.toString(16).padStart(64, "0"));
}
function hashSignal2(signal) {
  let input;
  if (signal instanceof Uint8Array) {
    input = signal;
  } else if (signal.startsWith("0x") && isValidHex(signal.slice(2))) {
    input = hexToBytes(signal.slice(2));
  } else {
    input = new TextEncoder().encode(signal);
  }
  return "0x" + bytesToHex(hashToField(input));
}
function isValidHex(s) {
  if (s.length === 0) return false;
  if (s.length % 2 !== 0) return false;
  return /^[0-9a-fA-F]+$/.test(s);
}

export { IDKit, IDKitErrorCodes, documentLegacy, hashSignal2 as hashSignal, isNode, isReactNative, isWeb, orbLegacy, secureDocumentLegacy, selfieCheck };
