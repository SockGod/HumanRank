export { RpSignature, signRequest } from '@worldcoin/idkit-server';
export { hashSignal } from './hashing.js';

/**
 * Configuration types for IDKit
 *
 * Note: CredentialType, CredentialRequestType, and ConstraintNode are now
 * re-exported from WASM (source of truth: rust/core/src/wasm_bindings.rs)
 */
declare const brand: unique symbol;
type Brand<T, TBrand extends string> = T & {
    [brand]: TBrand;
};
type AbiEncodedValue = Brand<{
    types: string[];
    values: unknown[];
}, "AbiEncodedValue">;
/**
 * Relying Party context for IDKit requests
 *
 * Contains RP-specific data needed to construct a ProofRequest.
 * This should be generated and signed by your backend.
 */
type RpContext = {
    /** The registered RP ID (e.g., "rp_123456789abcdef0") */
    rp_id: string;
    /** Unique nonce for this proof request */
    nonce: string;
    /** Unix timestamp (seconds since epoch) when created */
    created_at: number;
    /** Unix timestamp (seconds since epoch) when expires */
    expires_at: number;
    /** The RP's ECDSA signature of the nonce and created_at timestamp */
    signature: string;
};
/**
 * Configuration for IDKit.request()
 */
type IDKitRequestConfig = {
    /** Unique identifier for the app verifying the action. This should be the app ID obtained from the Developer Portal. */
    app_id: `app_${string}`;
    /** Identifier for the action the user is performing. Should be left blank for [Sign in with Worldcoin](https://docs.world.org/id/sign-in). */
    action: AbiEncodedValue | string;
    /** RP context for protocol-level proof requests (required) */
    rp_context: RpContext;
    /** The description of the specific action (shown to users in World App). Only recommended for actions created on-the-fly. */
    action_description?: string;
    /** URL to a third-party bridge to use when connecting to the World App. Optional. */
    bridge_url?: string;
    /**
     * Whether to accept legacy (v3) World ID proofs as fallback.
     *
     * - `true`: Accept both v3 and v4 proofs. Use during migration.
     *   You must track both v3 and v4 nullifiers to prevent double-claims.
     * - `false`: Only accept v4 proofs. Use after migration cutoff or for new apps.
     */
    allow_legacy_proofs: boolean;
    /** Optional override for the connect base URL (e.g., for staging environments) */
    override_connect_base_url?: string;
    /** Optional environment override. Defaults to "production". */
    environment?: "production" | "staging";
};
/**
 * Configuration for IDKit.createSession() and IDKit.proveSession()
 *
 * Session requests don't have an action field - they're used for session-based
 * authentication where the user proves they're the same person across visits.
 *
 * Sessions are always World ID v4 - there is no legacy (v3) session support.
 */
type IDKitSessionConfig = {
    /** Unique identifier for the app verifying the session. This should be the app ID obtained from the Developer Portal. */
    app_id: `app_${string}`;
    /** RP context for protocol-level proof requests (required) */
    rp_context: RpContext;
    /** The description of the action (shown to users in World App). Optional. */
    action_description?: string;
    /** URL to a third-party bridge to use when connecting to the World App. Optional. */
    bridge_url?: string;
    /** Optional override for the connect base URL (e.g., for staging environments) */
    override_connect_base_url?: string;
    /** Optional environment override. Defaults to "production". */
    environment?: "production" | "staging";
};

interface OrbLegacyPreset {
    type: "OrbLegacy";
    signal?: string;
}

interface SecureDocumentLegacyPreset {
    type: "SecureDocumentLegacy";
    signal?: string;
}

interface DocumentLegacyPreset {
    type: "DocumentLegacy";
    signal?: string;
}

interface SelfieCheckPreset {
    /** Preview: Selfie Check is currently in preview. Contact us if you need it enabled. */
    type: "SelfieCheck";
    signal?: string;
}

type Preset = OrbLegacyPreset | SecureDocumentLegacyPreset | DocumentLegacyPreset | SelfieCheckPreset;



/** V4 response item for World ID v4 uniqueness proofs */
interface ResponseItemV4 {
    /** Credential identifier (e.g., "orb", "face", "document") */
    identifier: string;
    /** Signal hash (optional, included if signal was provided in request) */
    signal_hash?: string;
    /** Encoded World ID proof: first 4 elements are compressed Groth16 proof, 5th is Merkle root (hex strings). Compatible with WorldIDVerifier.sol */
    proof: string[];
    /** RP-scoped nullifier (hex) */
    nullifier: string;
    /** Credential issuer schema ID (1=orb, 2=face, 3=secure_document, 4=document, 5=device) */
    issuer_schema_id: number;
    /** Minimum expiration timestamp (unix seconds) */
    expires_at_min: number;
}

/** V3 response item for World ID v3 (legacy format) */
interface ResponseItemV3 {
    /** Credential identifier (e.g., "orb", "face") */
    identifier: string;
    /** Signal hash (optional, included if signal was provided in request) */
    signal_hash?: string;
    /** ABI-encoded proof (hex) */
    proof: string;
    /** Merkle root (hex) */
    merkle_root: string;
    /** Nullifier (hex) */
    nullifier: string;
}

/** Session response item for World ID v4 session proofs */
interface ResponseItemSession {
    /** Credential identifier (e.g., "orb", "face", "document") */
    identifier: string;
    /** Signal hash (optional, included if signal was provided in request) */
    signal_hash?: string;
    /** Encoded World ID proof: first 4 elements are compressed Groth16 proof, 5th is Merkle root (hex strings). Compatible with WorldIDVerifier.sol */
    proof: string[];
    /** Session nullifier: 1st element is the session nullifier, 2nd is the generated action (hex strings) */
    session_nullifier: string[];
    /** Credential issuer schema ID (1=orb, 2=face, 3=secure_document, 4=document, 5=device) */
    issuer_schema_id: number;
    /** Minimum expiration timestamp (unix seconds) */
    expires_at_min: number;
}

/** V3 result (legacy format - no session support) */
interface IDKitResultV3 {
    /** Protocol version 3.0 */
    protocol_version: "3.0";
    /** Nonce used in the request */
    nonce: string;
    /** Action identifier (only for uniqueness proofs) */
    action?: string;
    /** Action description (only if provided in input) */
    action_description?: string;
    /** Array of V3 credential responses */
    responses: ResponseItemV3[];
    /** The environment used for this request ("production" or "staging") */
    environment: string;
}

/** V4 result for uniqueness proofs */
interface IDKitResultV4 {
    /** Protocol version 4.0 */
    protocol_version: "4.0";
    /** Nonce used in the request */
    nonce: string;
    /** Action identifier (required for uniqueness proofs) */
    action: string;
    /** Action description (only if provided in input) */
    action_description?: string;
    /** Array of V4 credential responses */
    responses: ResponseItemV4[];
    /** The environment used for this request ("production" or "staging") */
    environment: string;
}

/** V4 result for session proofs */
interface IDKitResultSession {
    /** Protocol version 4.0 */
    protocol_version: "4.0";
    /** Nonce used in the request */
    nonce: string;
    /** Action description (only if provided in input) */
    action_description?: string;
    /** Session ID returned by the World App */
    session_id: string;
    /** Array of session credential responses */
    responses: ResponseItemSession[];
    /** The environment used for this request ("production" or "staging") */
    environment: string;
}

/**
 * The unified result structure for all proof types.
 * Check `session_id` to determine if this is a session proof:
 * - session_id !== undefined → session proof
 * - session_id === undefined → uniqueness proof
 */
type IDKitResult = IDKitResultV3 | IDKitResultV4 | IDKitResultSession;

/** Error codes from World App (mirrors Rust AppError) */
type IDKitErrorCode =
    | "user_rejected"
    | "verification_rejected"
    | "credential_unavailable"
    | "malformed_request"
    | "invalid_network"
    | "inclusion_proof_pending"
    | "inclusion_proof_failed"
    | "unexpected_response"
    | "connection_failed"
    | "max_verifications_reached"
    | "failed_by_host_app"
    | "generic_error";

/** Status returned from pollForStatus() */
type Status$1 =
    | { type: "waiting_for_connection" }
    | { type: "awaiting_confirmation" }
    | { type: "confirmed"; result: IDKitResult }
    | { type: "failed"; error: IDKitErrorCode };



type CredentialType = "orb" | "face" | "secure_document" | "document" | "device";

interface CredentialRequestType {
    type: CredentialType;
    /** Signal can be a string or raw bytes (Uint8Array) */
    signal?: string | Uint8Array;
    genesis_issued_at_min?: number;
    expires_at_min?: number;
}

type ConstraintNode =
    | CredentialRequestType
    | { any: ConstraintNode[] }
    | { all: ConstraintNode[] }
    | { enumerate: ConstraintNode[] };

/**
 * Result types - re-exported from WASM bindings
 *
 * Source of truth: rust/core/src/wasm_bindings.rs (typescript_custom_section)
 */

/**
 * IDKit error codes enum — runtime values for matching against errors.
 * Values mirror Rust's AppError enum (snake_case via serde rename_all).
 * Includes client-side codes (timeout, cancelled) not from World App.
 */
declare enum IDKitErrorCodes {
    UserRejected = "user_rejected",
    VerificationRejected = "verification_rejected",
    CredentialUnavailable = "credential_unavailable",
    MalformedRequest = "malformed_request",
    InvalidNetwork = "invalid_network",
    InclusionProofPending = "inclusion_proof_pending",
    InclusionProofFailed = "inclusion_proof_failed",
    UnexpectedResponse = "unexpected_response",
    ConnectionFailed = "connection_failed",
    MaxVerificationsReached = "max_verifications_reached",
    FailedByHostApp = "failed_by_host_app",
    GenericError = "generic_error",
    Timeout = "timeout",
    Cancelled = "cancelled"
}

interface BuilderConfig {
    type: "request" | "session" | "proveSession";
    app_id: string;
    action?: string;
    session_id?: string;
    rp_context?: RpContext;
    action_description?: string;
    bridge_url?: string;
    allow_legacy_proofs?: boolean;
    override_connect_base_url?: string;
    environment?: string;
}

/**
 * IDKit Request
 * Pure functional API for World ID verification - no dependencies
 */

/** Options for pollUntilCompletion() */
interface WaitOptions {
    /** Milliseconds between polls (default: 1000) */
    pollInterval?: number;
    /** Total timeout in milliseconds (default: 300000 = 5 minutes) */
    timeout?: number;
    /** AbortSignal for cancellation */
    signal?: AbortSignal;
}
/** Status returned from pollOnce() */
interface Status {
    type: "waiting_for_connection" | "awaiting_confirmation" | "confirmed" | "failed";
    result?: IDKitResult;
    error?: IDKitErrorCodes;
}
/** Result from pollUntilCompletion() — discriminated union, never throws */
type IDKitCompletionResult = {
    success: true;
    result: IDKitResult;
} | {
    success: false;
    error: IDKitErrorCodes;
};

/**
 * A World ID verification request
 *
 * Provides a clean, promise-based API for World ID verification flows.
 * Each request represents a single verification attempt.
 */
interface IDKitRequest {
    /** QR code URL for World App - display this as a QR code for users to scan */
    readonly connectorURI: string;
    /** Unique request ID for this verification */
    readonly requestId: string;
    /** Poll once for current status (for manual polling) */
    pollOnce(): Promise<Status>;
    /** Poll continuously until completion or timeout */
    pollUntilCompletion(options?: WaitOptions): Promise<IDKitCompletionResult>;
}
/**
 * Creates an OrbLegacy preset for World ID 3.0 legacy support
 *
 * This preset creates an IDKit request compatible with both World ID 4.0 and 3.0 protocols.
 * Use this when you need backward compatibility with older World App versions.
 *
 * @param opts - Optional configuration with signal
 * @returns An OrbLegacy preset
 *
 * @example
 * ```typescript
 * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: true })
 *   .preset(orbLegacy({ signal: 'user-123' }))
 * ```
 */
declare function orbLegacy(opts?: {
    signal?: string;
}): OrbLegacyPreset;
/**
 * Creates a SecureDocumentLegacy preset for World ID 3.0 legacy support
 *
 * This preset creates an IDKit request compatible with both World ID 4.0 and 3.0 protocols.
 * Use this when you need backward compatibility with older World App versions.
 *
 * @param opts - Optional configuration with signal
 * @returns A SecureDocumentLegacy preset
 *
 * @example
 * ```typescript
 * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: true })
 *   .preset(secureDocumentLegacy({ signal: 'user-123' }))
 * ```
 */
declare function secureDocumentLegacy(opts?: {
    signal?: string;
}): SecureDocumentLegacyPreset;
/**
 * Creates a DocumentLegacy preset for World ID 3.0 legacy support
 *
 * This preset creates an IDKit request compatible with both World ID 4.0 and 3.0 protocols.
 * Use this when you need backward compatibility with older World App versions.
 *
 * @param opts - Optional configuration with signal
 * @returns A DocumentLegacy preset
 *
 * @example
 * ```typescript
 * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: true })
 *   .preset(documentLegacy({ signal: 'user-123' }))
 * ```
 */
declare function documentLegacy(opts?: {
    signal?: string;
}): DocumentLegacyPreset;
/**
 * Creates a SelfieCheck preset for face verification
 *
 * Preview: Selfie Check is currently in preview.
 * Contact us if you need it enabled.
 *
 * This preset requests face credentials in v4 constraints.
 * In legacy compatibility fields, it maps to verification level "face".
 *
 * @param opts - Optional configuration with signal
 * @returns A SelfieCheck preset
 *
 * @example
 * ```typescript
 * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: false })
 *   .preset(selfieCheck({ signal: 'user-123' }))
 * ```
 */
declare function selfieCheck(opts?: {
    signal?: string;
}): SelfieCheckPreset;
/**
 * Builder for IDKit requests
 *
 * Stores configuration and defers transport selection to `.preset()` / `.constraints()`.
 * In World App: uses native postMessage transport (no WASM needed).
 * On web: uses WASM bridge transport (QR code + polling).
 */
declare class IDKitBuilder {
    private config;
    constructor(config: BuilderConfig);
    /**
     * Creates an IDKit request with the given constraints
     *
     * @param constraints - Constraint tree (CredentialRequest or any/all/enumerate combinators)
     * @returns A new IDKitRequest instance
     *
     * @example
     * ```typescript
     * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: false })
     *   .constraints(any(CredentialRequest('orb'), CredentialRequest('face')));
     * ```
     */
    constraints(constraints: ConstraintNode): Promise<IDKitRequest>;
    /**
     * Creates an IDKit request from a preset (works for all request types)
     *
     * Presets provide a simplified way to create requests with predefined
     * credential configurations.
     *
     * @param preset - A preset object from orbLegacy(), secureDocumentLegacy(), documentLegacy(), or selfieCheck()
     * @returns A new IDKitRequest instance
     *
     * @example
     * ```typescript
     * const request = await IDKit.request({ app_id, action, rp_context, allow_legacy_proofs: true })
     *   .preset(orbLegacy({ signal: 'user-123' }));
     * ```
     */
    preset(preset: Preset): Promise<IDKitRequest>;
}
/**
 * Creates an IDKit verification request builder
 *
 * This is the main entry point for creating World ID verification requests.
 * Use the builder pattern with `.preset()` or `.constraints()` to specify
 * which credentials to accept.
 *
 * @param config - Request configuration
 * @returns IDKitBuilder - A builder instance
 *
 * @example
 * ```typescript
 * import { IDKit, CredentialRequest, any, enumerate, orbLegacy } from '@worldcoin/idkit-core'
 *
 * // With preset (legacy support)
 * const request = await IDKit.request({
 *   app_id: 'app_staging_xxxxx',
 *   action: 'my-action',
 *   rp_context: { ... },
 *   allow_legacy_proofs: true,
 * }).preset(orbLegacy({ signal: 'user-123' }));
 *
 * // With constraints (v4 only)
 * const request = await IDKit.request({
 *   app_id: 'app_staging_xxxxx',
 *   action: 'my-action',
 *   rp_context: { ... },
 *   allow_legacy_proofs: false,
 * }).constraints(enumerate(CredentialRequest('orb'), CredentialRequest('face')));
 *
 * // In World App: connectorURI is empty, result comes via postMessage
 * // On web: connectorURI is the QR URL to display
 * console.log(request.connectorURI);
 *
 * // Wait for result — same interface in both environments
 * const proof = await request.pollUntilCompletion();
 * ```
 */
declare function createRequest(config: IDKitRequestConfig): IDKitBuilder;
/**
 * IDKit namespace providing the main API entry points
 *
 * @example
 * ```typescript
 * import { IDKit, CredentialRequest, any, enumerate, orbLegacy } from '@worldcoin/idkit-core'
 *
 * // Create a verification request
 * const request = await IDKit.request({
 *   app_id: 'app_staging_xxxxx',
 *   action: 'my-action',
 *   rp_context: { ... },
 *   allow_legacy_proofs: true,
 * }).preset(orbLegacy({ signal: 'user-123' }))
 *
 * // In World App: result comes via postMessage (no QR needed)
 * // On web: display QR code and wait for proof
 * console.log(request.connectorURI)
 * const proof = await request.pollUntilCompletion()
 * ```
 */
declare const IDKit: {
    /** Create a new verification request */
    request: typeof createRequest;
    /** Create an OrbLegacy preset for World ID 3.0 legacy support */
    orbLegacy: typeof orbLegacy;
    /** Create a SecureDocumentLegacy preset for World ID 3.0 legacy support */
    secureDocumentLegacy: typeof secureDocumentLegacy;
    /** Create a DocumentLegacy preset for World ID 3.0 legacy support */
    documentLegacy: typeof documentLegacy;
    /** Create a SelfieCheck preset for face verification */
    selfieCheck: typeof selfieCheck;
};

/**
 * Platform detection utilities
 *
 * These functions help detect the runtime environment (React Native, Web, Node.js)
 * to enable platform-specific behavior or warnings.
 */
/**
 * Checks if the code is running in React Native environment
 * @returns true if running in React Native, false otherwise
 */
declare const isReactNative: () => boolean;
/**
 * Checks if the code is running in a web browser environment
 * @returns true if running in a browser, false otherwise
 */
declare const isWeb: () => boolean;
/**
 * Checks if the code is running in Node.js environment
 * @returns true if running in Node.js, false otherwise
 */
declare const isNode: () => boolean;

export { type AbiEncodedValue, type ConstraintNode, type CredentialRequestType, type CredentialType, type DocumentLegacyPreset, IDKit, type IDKitCompletionResult, type IDKitErrorCode, IDKitErrorCodes, type IDKitRequest, type IDKitRequestConfig, type IDKitResult, type IDKitResultSession, type IDKitSessionConfig, type OrbLegacyPreset, type Preset, type ResponseItemSession, type ResponseItemV3, type ResponseItemV4, type RpContext, type SecureDocumentLegacyPreset, type SelfieCheckPreset, type Status$1 as Status, type WaitOptions, documentLegacy, isNode, isReactNative, isWeb, orbLegacy, secureDocumentLegacy, selfieCheck };
