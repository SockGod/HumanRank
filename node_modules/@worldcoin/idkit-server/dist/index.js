import { keccak_256 } from '@noble/hashes/sha3';
import { bytesToHex, hexToBytes } from '@noble/hashes/utils';
import { hmac } from '@noble/hashes/hmac';
import { sha256 } from '@noble/hashes/sha2';
import { etc, sign } from '@noble/secp256k1';

// src/lib/signing.ts

// src/lib/platform.ts
var isServerEnvironment = () => {
  if (typeof process !== "undefined" && process.versions?.node) {
    return true;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return true;
  }
  if (typeof globalThis.Bun !== "undefined") {
    return true;
  }
  return false;
};

// src/lib/signing.ts
etc.hmacSha256Sync = (key, ...msgs) => hmac(sha256, key, etc.concatBytes(...msgs));
var DEFAULT_TTL_SEC = 300;
function hashToField(input) {
  const hash = BigInt("0x" + bytesToHex(keccak_256(input))) >> 8n;
  return hexToBytes(hash.toString(16).padStart(64, "0"));
}
function computeRpSignatureMessage(nonceBytes, createdAt, expiresAt) {
  const message = new Uint8Array(48);
  message.set(nonceBytes, 0);
  const view = new DataView(message.buffer);
  view.setBigUint64(32, BigInt(createdAt), false);
  view.setBigUint64(40, BigInt(expiresAt), false);
  return message;
}
function signRequest(_action, signingKeyHex, ttl = DEFAULT_TTL_SEC) {
  if (!isServerEnvironment()) {
    throw new Error(
      "signRequest can only be used in Node.js environments. This function requires access to signing keys and should never be called from browser/client-side code."
    );
  }
  const keyHex = signingKeyHex.startsWith("0x") ? signingKeyHex.slice(2) : signingKeyHex;
  if (!/^[0-9a-fA-F]+$/.test(keyHex)) {
    throw new Error("Invalid signing key: contains non-hex characters");
  }
  if (keyHex.length !== 64) {
    throw new Error(
      `Invalid signing key: expected 32 bytes (64 hex chars), got ${keyHex.length / 2} bytes`
    );
  }
  const privKey = etc.hexToBytes(keyHex);
  const randomBytes = crypto.getRandomValues(new Uint8Array(32));
  const nonceBytes = hashToField(randomBytes);
  const createdAt = Math.floor(Date.now() / 1e3);
  const expiresAt = createdAt + ttl;
  const message = computeRpSignatureMessage(nonceBytes, createdAt, expiresAt);
  const msgHash = keccak_256(message);
  const recSig = sign(msgHash, privKey);
  const compact = recSig.toCompactRawBytes();
  const sig65 = new Uint8Array(65);
  sig65.set(compact, 0);
  sig65[64] = recSig.recovery + 27;
  return {
    sig: "0x" + bytesToHex(sig65),
    nonce: "0x" + bytesToHex(nonceBytes),
    createdAt,
    expiresAt
  };
}

export { computeRpSignatureMessage, signRequest };
