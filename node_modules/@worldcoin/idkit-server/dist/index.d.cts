interface RpSignature {
    sig: string;
    nonce: string;
    createdAt: number;
    expiresAt: number;
}
/**
 * Builds the 48-byte message that gets signed for RP signature verification.
 *
 * Message format: nonce(32) || createdAt_u64_be(8) || expiresAt_u64_be(8)
 *
 * Matches Rust `compute_rp_signature_msg`:
 * https://github.com/worldcoin/world-id-protocol/blob/0008eab1efe200e572f27258793f9be5cb32858b/crates/primitives/src/rp.rs#L95-L105
 *
 * @param nonceBytes - 32-byte nonce as Uint8Array
 * @param createdAt - unix timestamp in seconds
 * @param expiresAt - unix timestamp in seconds
 * @returns 48-byte message ready to be hashed and signed
 */
declare function computeRpSignatureMessage(nonceBytes: Uint8Array, createdAt: number, expiresAt: number): Uint8Array;
/**
 * Signs an RP request using pure JS (no WASM required).
 *
 * Algorithm matches Rust implementation in rust/core/src/rp_signature.rs
 *
 * Nonce generation matches `from_arbitrary_raw_bytes`:
 * https://github.com/worldcoin/world-id-protocol/blob/31405df8bcd5a2784e04ad9890cf095111dcac13/crates/primitives/src/lib.rs#L134-L149
 *
 * @param action - The action tied to the proof request (accepted for API compat, not used in signature)
 * @param signingKeyHex - The ECDSA private key as hex (0x-prefixed or not, 32 bytes)
 * @param ttl - Time-to-live in seconds (defaults to 300 = 5 minutes)
 * @returns RpSignature object with sig, nonce, createdAt, expiresAt
 */
declare function signRequest(_action: string, signingKeyHex: string, ttl?: number): RpSignature;

export { type RpSignature, computeRpSignatureMessage, signRequest };
